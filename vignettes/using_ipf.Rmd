---
title: "Using ipf"
author: "Kyle Ward"
date: "`r Sys.Date()`"
output: 
  knitr:::html_vignette:
    toc: yes
vignette: >
  %\VignetteIndexEntry{ipf}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=FALSE,echo=TRUE,
                      message=TRUE,warning=TRUE,error=TRUE)
options(scipen=999) # removes sci notation
```

# Introduction

This package provides a generic implimentation of the iterative proportional 
fitting algorithm or
[IPF](https://en.wikipedia.org/wiki/Iterative_proportional_fitting) in the
`ipf()` function. It also provides an iterative proportional updating algorithm
([IPU](http://www.scag.ca.gov/Documents/PopulationSynthesizerPaper_TRB.pdf)) for
balancing household- and person-level marginals in the `ipu()` function.

# IPF

The `ipf()` function is intended for basic IPF operations. It has
many applications in different fields, but in transportation, you
can use it to:

  * Grow a base year through-trip table to future year station volumes.
  * Expand a household survey to multiple household marginal distributions (any number of them).
  * Expand a synthetic population seed (like PUMS data) to create base or future-year synthetic populations.
  
In more general terms, IPF takes a seed distribution with rich relational 
information and weights it to match various 1-dimensional marginal
distributions. The first example explains further.

## Example 1: Basics

This section creates a random seed table and target values to illustrate how the
package is used. The targets are specified for three separate clusters, which
could represent model TAZs, survey districts, or some other grouping of 
geographic areas.

### Seed table creation
The seed table is the starting point for the IPF procedure.  In this example, 
we will use a made up summary table of survey data.  This fake table is a count 
of households by the number persons, workers and vehicles.  A sample of the 
table is shown for illustration.  The count is stored in the `weight` field.
```{r "seed creation", message=FALSE,warning=FALSE,error=FALSE}
library(dplyr)
library(tidyr)
library(ipfr)
library(htmlTable)

seed <- expand.grid(
  siz = c(1, 2, 3, 4),
  wrk = c(0, 1, 2, 3),
  veh = c(0, 1, 2, 3)
) %>% tbl_df()

set.seed(1)
seed$weight <- sample(1:10, nrow(seed), replace = TRUE)

seed %>%
  head() %>%
  htmlTable(
  align = "cccr", col.rgroup = c("none", "#F7F7F7"), rnames = FALSE
)
```


### Target creation
The number of households by size (e.g., 1-person, 2-person, etc.) is referred to
as a marginal distribution.  Often, from the Census, we know the total number of 
households by each individual marginal.  For example, we know the number of 
households by size:

  * 1 person: 150 households
  * 2 persons: 150 households
  * 3 persons: 100 households
  * 4+ persons: 100 households

This information becomes the target that the IPF process tries to match.

This information is created below for the distribution of households by size, 
number of workers, and number of vehicles.  The size table is shown as an example.
Across the top are the marginal categories (1-4). The cluster column represents
three separate geographies (counties, tracts, TAZs, etc.).
```{r "marginal creation"}

targets <- list()
targets$siz <- data_frame(
  cluster = c(1, 2, 3),
  `1` = c(100, 150, 0),
  `2` = c(100, 100, 0),
  `3` = c(150, 100, 0),
  `4` = c(150, 150, 0)
)
targets$wrk <- data_frame(
  cluster = c(1, 2, 3),
  `0` = c(100, 100, 0),
  `1` = c(150, 100, 0),
  `2` = c(150, 150, 0),
  `3` = c(100, 150, 0)
)
targets$veh <- data_frame(
  cluster = c(1, 2, 3),
  `0` = c(75, 175, 0),
  `1` = c(175, 75, 0),
  `2` = c(150, 150, 0),
  `3` = c(100, 100, 0)
)

targets$siz %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size Targets"
  )  
```

### The Goal
We know the count of each marginal individually, but assume we don't have 
official information from the Census about the joint distribution.  What we want
to do is use the joint distribution from our survey, but ensure it agrees with 
the marginal information from the Census.

An initial test comparing sizes for cluster 1 shows they do not agree.
```{r "initial test"}
siz <- targets$siz %>%
  filter(cluster == 1) %>%
  gather(key = siz, value = target, -cluster) %>%
  mutate(siz = as.numeric(siz)) %>%
  select(-cluster)
  

seed %>%
  select(siz, weight) %>%
  group_by(siz) %>%
  summarize(seed = sum(weight)) %>%
  left_join(siz, by = "siz") %>%
  htmlTable(
    align = "crr", rnames = FALSE,
    caption = "Comparing size marginals for cluster 1"
  )
```

### Using IPF

We can use the ipfr package to change this.  For this example, the `verbose`
option is turned on to show what the tool reports upon completion. It reports 
the worst-performing marginal in the worst-performing cluster. If these
values are small, then you can be confident in the result.
```{r}
table <- ipf(seed, targets, verbose = TRUE)
```

A sample of the resulting table is shown below.
```{r}
table %>%
  mutate_all(funs(round(., 2))) %>%
  head() %>%
  htmlTable(
    align = "crr", rnames = FALSE
  )
```

### Summarizing Results

We can summarize the final table to see if it worked.
```{r}
table %>%
  select(-c(wrk, veh)) %>%
  group_by(cluster, siz) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = siz, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Result"
  )

targets$siz %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Target"
  )
```

Not only does the marginal distribution of size match, but also workers and vehicles.
```{r, echo=FALSE}
# Workers
table %>%
  select(-c(siz, veh)) %>%
  group_by(cluster, wrk) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = wrk, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Workers: Result"
  )

targets$wrk %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Workers: Target"
  )

# Vehciles
table %>%
  select(-c(siz, wrk)) %>%
  group_by(cluster, veh) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = veh, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Vehicles: Result"
  )

targets$veh %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Vehciles: Target"
  )
```

```{r}
# Saving seed and target for examples after example 2.
first_seed <- seed
first_targets <- targets
```

## Example 2: Survey Expansion using Geographical Clusters

In the first example, target values were specified for various clusters, but no
target information was appended to the seed table. In this case, `ipfr` assumes
that the full seed table is used as a starting point for every cluster.

In the case of survey expansion, it is common to define clusters in both the 
seed and target table. With this approach, only the seed records in a cluster
will be expanded to match that cluster's targets.

Accomplishing this is as simple as appending the `cluster` values to the seed 
table. We will create a new seed table, and append cluster values into a new
`cluster` field. Note that `cluster` is a special field name and must be used in
both seed and target tables for this to work.

```{r}
seed <- data_frame(
  hhid = c(1, 2, 3, 4),
  siz = c(1, 2, 1, 1),
  weight = c(1, 1, 1, 1),
  cluster = c(1, 1, 2, 2)
)

seed %>%
  htmlTable(
    rnames = FALSE, caption = "Seed Table with Cluster Appended"
  )
```

New targets are specified:

```{r}
targets <- list()
targets$siz <- data_frame(
  cluster = c(1, 2),
  `1` = c(75, 100),
  `2` = c(25, 150)
)
```

Run `ipf`. Note that it picks up a new error. When providing cluster values in the seed
table, `ipfr` checks to make sure that every marginal category appears in every cluster.
In this case, the full seed table does contain both size 1 and 2 records, but cluster
2 only has size 1.

```{r}
result <- ipf(seed = seed, targets = targets)
```

Fix the seed table and re-run `ipf`.

```{r}
seed <- data_frame(
  hhid = c(1, 2, 3, 4),
  siz = c(1, 2, 2, 1),
  weight = c(1, 1, 1, 1),
  cluster = c(1, 1, 2, 2)
)

result <- ipf(seed = seed, targets = targets)
```


In the resulting table, note that the first two rows in the seed table (in 
cluster 1) match the 100 household total of cluster 1, while the second two
rows match the 250 household total of cluster 2.

```{r}
result %>%
  htmlTable(
    rnames = FALSE, caption = "Survey Expansion to Clusters"
  )
```

# IPU

Iterative proportional updating is a method developed by Arizona State University
that allows the IPF procedure to match household- and person-level marginals. In
that basic IPF procedure, all marginal distributions must describe the same thing
(e.g. households). IPU allows you to say, for example, that a zone needs a total
household count of 500, but also needs 800 people.

## Example 1: Combining Household and Person Marginals

In household survey expansion, it is common to want to control for certain
features that describe households, (like size), while controlling for other
attributes that describe people (like age). This is possible with `ipfr`.

First consider a household table of four households with varying sizes.

```{r}
hh_seed <- expand.grid(
  geo_cluster = c(1, 2, 3),
  siz = c(1, 2, 3, 4),
  veh = c(0, 1, 2),
  wrk = c(0, 1, 2)
) %>% 
  tbl_df() %>%
  mutate(hhid = seq(1, nrow(.))) %>%
  select(geo_cluster, hhid, siz, veh, wrk)

hh_seed[c(1:3, 45:48), ] %>%
  htmlTable(
    rnames = FALSE, caption = "Survey Household Table"
  )
```

That household table has an associated person table shown below. `age_group`
takes on values between 1-4, and for clarity, let's say they represent the
following:

  * ag_1 Under 18
  * ag_2 Between 18 and 25
  * ag_3 Between 25 and 50
  * ag_4 Over 50

```{r}
# pick a random number of persons per household
per_seed <- hh_seed %>%
  select(hhid, siz)

# expand the data frame to be one row per person and pick a random
# age group.
per_seed <- per_seed[rep(per_seed$hhid, per_seed$siz), ] %>%
  group_by(hhid) %>%
  mutate(
    perid = seq(1, n()),
    age_group = sample(1:4, n(), replace = TRUE),
    age_group = paste0("ag_", age_group)
  ) %>%
  select(-siz) %>%
  ungroup()

per_seed %>%
  head() %>%
  htmlTable(
    rnames = FALSE, caption = "Survey Person Table"
  )
```

Create separate targets for households and persons.

```{r}
hh_targets <- list()
hh_targets$siz <- data_frame(
  geo_cluster = c(1, 2, 3),
  `1` = c(100, 150, 0),
  `2` = c(100, 100, 0),
  `3` = c(150, 100, 0),
  `4` = c(150, 150, 0)
)
hh_targets$wrk <- data_frame(
  geo_cluster = c(1, 2, 3),
  `0` = c(100, 100, 0),
  `1` = c(150, 100, 0),
  `2` = c(250, 300, 0)
)
hh_targets$veh <- data_frame(
  geo_cluster = c(1, 2, 3),
  `0` = c(75, 175, 0),
  `1` = c(175, 75, 0),
  `2` = c(250, 250, 0)
)

per_targets <- list()
per_targets$age_group <- data_frame(
  geo_cluster = c(1, 2, 3),
  ag_1 = c(100, 150, 0),
  ag_2 = c(300, 250, 0),
  ag_3 = c(100, 150, 0),
  ag_4 = c(300, 250, 0)
)
```

Call the ipu function.

```{r}
result <- ipu(hh_seed, hh_targets, per_seed, per_targets,
              damp_factor = 1, max_iterations = 50,
              verbose = TRUE)

result %>%
  head() %>%
  mutate(weight = round(weight, 2)) %>%
  htmlTable(
    rnames = FALSE, caption = "IPF Result"
  )
```

After running for the default of 50 iterations, the weights
are nearly balanced for both persons and households. The table
below shows that the total number of households by cluster
is nearing the target.

```{r}
# summarize the hh targets to get total hh per cluster
tot_hh_target <- hh_targets$siz %>%
  gather(key = siz, value = target, -geo_cluster) %>%
  group_by(geo_cluster) %>%
  summarize(target = sum(target))

result %>%
  group_by(geo_cluster) %>%
  summarize(weight = round(sum(weight), 0)) %>%
  left_join(tot_hh_target, by = "geo_cluster")
```

The second table below shows that the number of persons per
cluster is also nearing its target.

```{r}
# summarize the person targets to get total persons
# per cluster
tot_per_target <- per_targets$age_group %>%
  gather(key = age_group, value = target, -geo_cluster) %>%
  group_by(geo_cluster) %>%
  summarize(target = sum(target))
  
# Create a comparison table to the result
per_seed %>%
  left_join(
    result %>% select(hhid, weight, geo_cluster),
    by = "hhid"
  ) %>%
  group_by(geo_cluster) %>%
  summarize(weight = round(sum(weight), 0)) %>%
  left_join(tot_per_target, by = "geo_cluster") %>%
  htmlTable(
    rnames = FALSE, caption = "Comparing Persons per Cluster"
  )
```

The final table shows more detail and compares the age
distributions by cluster.

```{r}
# summarize the person targets to get persons by age
tot_per_target <- per_targets$age_group %>%
  gather(key = age_group, value = target, -geo_cluster) %>%
  group_by(geo_cluster, age_group) %>%
  summarize(target = sum(target))

per_seed %>%
  left_join(
    result %>% select(hhid, weight, geo_cluster),
    by = "hhid"
  ) %>%
  group_by(geo_cluster, age_group) %>%
  summarize(weight = round(sum(weight), 0)) %>%
  left_join(
    tot_per_target, 
    by = c("geo_cluster" = "geo_cluster", "age_group" = "age_group")
  ) %>%
  htmlTable(
    rnames = FALSE,
    caption = "Comparing Persons per Cluster and Age"
  )
```

## Example 2: Different Geographies

One of the latest enhancements to `ipu()` is to allow different geographies to
be specified for different marginal tables. There are a few rules that make
this possible, but in short, the geo field on each target table tells the
algorithm which scale to constrain to.

All of the following rules are checked by the algorithm and you will get a
message telling you if you violated one.

  * All fields that designate geographies must start with "geo_"
    * geo_cluster
    * geo_region
    * geo_state
  * The household seed table must contain all geo fields used by any target table
    * (The household seed must still have the `hhid` column.)
  * Do **not** put any geo fields on the the person seed table.
    * This prevents any errors/differences from breaking the algorithm.
  * Each target table must have a geo field that is present in the hh_seed

In this example, the household targets will be applied at the cluster level
as before, but the person (age) targets will be applied at the region only.

Add a `geo_region` field to the `hh_seed` table.

```{r}
hh_seed$geo_region <- 1

hh_seed %>%
  head() %>%
  htmlTable(rnames = FALSE, caption = "hh_seed with geo_region")
```

Collapse the person age target table to the region.

```{r}
per_targets$age_group <- per_targets$age_group %>%
  summarize_all(.funs = sum) %>%
  rename(geo_region = geo_cluster) %>%
  mutate(geo_region = 1)
```

Run `ipu()`.

```{r}
result <- ipu(hh_seed, hh_targets, per_seed, per_targets, damp_factor = 1,
              verbose = TRUE, max_iterations = 10)

result %>%
  head() %>%
  htmlTable(rnames = FALSE, caption = "Example 2 Result")
```

I stopped the algorithm early (10 iterations) to show results that are not quite
exact. Even so, they are already close. Summarize the household marginal
distribution with the worst gap:

```{r}
tot_hh_target <- hh_targets$siz %>%
  gather(key = siz, value = target, -geo_cluster) %>%
  filter(siz == 1) %>%
  group_by(geo_cluster) %>%
  summarize(target = sum(target))

result %>%
  filter(siz == 1) %>%
  group_by(geo_cluster) %>%
  summarize(weight = round(sum(weight), 0)) %>%
  left_join(tot_hh_target, by = "geo_cluster")
```


A summary of the person attributes shows them nearly matching at the regional level.

```{r}
# summarize the person targets to get persons by age
tot_per_target <- per_targets$age_group %>%
  gather(key = age_group, value = target, -geo_region)

per_seed %>%
  left_join(
    result %>% select(hhid, weight),
    by = "hhid"
  ) %>%
  group_by(age_group) %>%
  summarize(weight = round(sum(weight), 0)) %>%
  left_join(
    tot_per_target, 
    by = c("age_group" = "age_group")
  ) %>%
  select(-geo_region) %>%
  htmlTable(
    rnames = FALSE,
    caption = "Comparing Persons per Cluster and Age"
  )
```



# How IPFR addresses common IPF problems

This section will show how `ipfr` addresses some common problems found in basic
ipf procedures. It uses the example data from the first example.

```{r}
seed <- first_seed
targets <- first_targets
```


## Zero weights

Both `ipf()` and `ipu()` implement this improvement.

IPF works by successively multiplying the table weights by factors.  Cells with 
a zero weight cannot be modified by this process.  As the number of zero weights 
increase, the flexibility of the process is reduced, and convergence becomes 
more difficult. `ipfr` solves this problem by setting a minimum weight for all 
cells to `.0001`.  This minimum weight can be adjusted using the `min_weight` 
parameter and should be arbitrarily small compared to your seed table weights.

## Missing seed information

Both `ipf()` and `ipu()` implement this improvement.

Not every combination of marginal categories is required to be included in the 
seed table; however, at least one observation of each category must exist.  For example, the combination:

  * siz = 1
  * wrk = 1
  * veh = 0

may not have been observed in the survey, and thus may be missing from the seed 
table.  As long as other combinations of size-1 households exist (e.g. with 0 workers and 1 vehicle), `ipfr` will work fine.  On the other hand, if there are no observations of any size-1 households, `ipfr` will stop with an error message.

```{r, warning=TRUE}
missing_seed <- seed %>%
  filter(siz != 1)

error <- try(table <- ipf(missing_seed, targets))
error[1]
```

## Marginal agreement

Only `ipf()` implements this improvement. `ipu()` assumes that at least some
marginals *should* disagree on the total.

In our first IPF example, the marginal distributions of households all add up to
the same number for each zone (500, 500, and 0). If they disagreed on the total
number of households, the standard IPF process could not converge.

Occasionally, marginal distributions might disagree slightly on the totals, particularly 
if they are derived from different sources.  When that happens, `ipf()` 
will still converge by matching the total of the first marginal table supplied 
while using the percentage distribution from the remaining tables. The eliminates
the painful task of ensuring all marginals match exactly.

```{r, warning=TRUE}
# Increase 1-person households from 100 to 500
targets$siz <- data_frame(
  cluster = c(1, 2, 3),
  `1` = c(500, 500, 0),
  `2` = c(100, 100, 0),
  `3` = c(150, 100, 0),
  `4` = c(150, 150, 0)
)

table <- ipf(seed, targets)
```

```{r, echo=FALSE}
# Size
table %>%
  select(-c(wrk, veh)) %>%
  group_by(cluster, siz) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = siz, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Result"
  )

targets$siz %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Target"
  )

# Workers
table %>%
  select(-c(siz, veh)) %>%
  group_by(cluster, wrk) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = wrk, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Workers: Result"
  )

targets$wrk %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Workers: Target"
  )

# Vehciles
table %>%
  select(-c(siz, wrk)) %>%
  group_by(cluster, veh) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = veh, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Vehicles: Result"
  )

targets$veh %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Vehciles: Target"
  )
```

## Partial marginals

Both `ipf()` and `ipu()` implement this improvement.

In some applications of IPF, there may not be a need to control every category of every marginal.  In this example, perhaps you want to control 1-, 2-, and 3-person households, but are not concerned with 4+ person households.

```{r}
partial_targets <- targets
partial_targets$siz <- data_frame(
  cluster = c(1, 2, 3),
  `1` = c(100, 150, 0),
  `2` = c(100, 100, 0),
  `3` = c(150, 100, 0)
)

table <- ipf(seed, partial_targets)
```

As shown below, the marginal distributions of size categories 1, 2, and 3 are fairly close to their target values, while 4+ is not.

```{r}
table %>%
  select(-c(wrk, veh)) %>%
  group_by(cluster, siz) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = siz, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Result"
  )

partial_targets$siz %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Target"
  )
```